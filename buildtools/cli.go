package buildtools

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/BurntSushi/toml"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/container/strategies"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/python"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/setup"
	"github.com/jfrog/jfrog-cli-core/v2/artifactory/utils"
	"github.com/jfrog/jfrog-cli-core/v2/utils/ioutils"
	"github.com/jfrog/jfrog-cli-security/utils/techutils"
	"github.com/jfrog/jfrog-cli/docs/buildtools/helmcommand"
	"github.com/jfrog/jfrog-cli/docs/buildtools/rubyconfig"
	setupdocs "github.com/jfrog/jfrog-cli/docs/buildtools/setup"

	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/container"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/dotnet"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/golang"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/gradle"
	helmcmd "github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/helm"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/mvn"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/npm"
	containerutils "github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/ocicontainer"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/terraform"
	"github.com/jfrog/jfrog-cli-artifactory/artifactory/commands/yarn"
	commandsUtils "github.com/jfrog/jfrog-cli-core/v2/artifactory/commands/utils"
	"github.com/jfrog/jfrog-cli-core/v2/common/build"
	commonCliUtils "github.com/jfrog/jfrog-cli-core/v2/common/cliutils"
	"github.com/jfrog/jfrog-cli-core/v2/common/commands"
	outputFormat "github.com/jfrog/jfrog-cli-core/v2/common/format"
	"github.com/jfrog/jfrog-cli-core/v2/common/project"
	corecommon "github.com/jfrog/jfrog-cli-core/v2/docs/common"
	"github.com/jfrog/jfrog-cli-core/v2/plugins/components"
	coreConfig "github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-cli-core/v2/utils/coreutils"
	securityCLI "github.com/jfrog/jfrog-cli-security/cli"
	securityDocs "github.com/jfrog/jfrog-cli-security/cli/docs"
	"github.com/jfrog/jfrog-cli-security/commands/scan"
	terraformdocs "github.com/jfrog/jfrog-cli/docs/artifactory/terraform"
	"github.com/jfrog/jfrog-cli/docs/artifactory/terraformconfig"
	twinedocs "github.com/jfrog/jfrog-cli/docs/artifactory/twine"
	"github.com/jfrog/jfrog-cli/docs/buildtools/conan"
	"github.com/jfrog/jfrog-cli/docs/buildtools/docker"
	dotnetdocs "github.com/jfrog/jfrog-cli/docs/buildtools/dotnet"
	"github.com/jfrog/jfrog-cli/docs/buildtools/dotnetconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/gocommand"
	"github.com/jfrog/jfrog-cli/docs/buildtools/goconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/gopublish"
	gradledoc "github.com/jfrog/jfrog-cli/docs/buildtools/gradle"
	"github.com/jfrog/jfrog-cli/docs/buildtools/gradleconfig"
	mvndoc "github.com/jfrog/jfrog-cli/docs/buildtools/mvn"
	"github.com/jfrog/jfrog-cli/docs/buildtools/mvnconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/npmcommand"
	"github.com/jfrog/jfrog-cli/docs/buildtools/npmconfig"
	nugetdocs "github.com/jfrog/jfrog-cli/docs/buildtools/nuget"
	"github.com/jfrog/jfrog-cli/docs/buildtools/nugetconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/pipconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/pipenvconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/pipenvinstall"
	"github.com/jfrog/jfrog-cli/docs/buildtools/pipinstall"
	"github.com/jfrog/jfrog-cli/docs/buildtools/pnpmconfig"
	"github.com/jfrog/jfrog-cli/docs/buildtools/poetry"
	"github.com/jfrog/jfrog-cli/docs/buildtools/poetryconfig"
	yarndocs "github.com/jfrog/jfrog-cli/docs/buildtools/yarn"
	"github.com/jfrog/jfrog-cli/docs/buildtools/yarnconfig"
	"github.com/jfrog/jfrog-cli/docs/common"
	"github.com/jfrog/jfrog-cli/utils/buildinfo"
	"github.com/jfrog/jfrog-cli/utils/cliutils"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"github.com/urfave/cli"
)

const (
	buildToolsCategory = "Package Managers:"
)

func GetCommands() []cli.Command {
	cmds := cliutils.GetSortedCommands(cli.CommandsByName{
		{
			// Currently, the setup command is hidden from the help menu, till it will be released as GA.
			Hidden:       true,
			Name:         "setup",
			Flags:        cliutils.GetCommandFlags(cliutils.Setup),
			Usage:        setupdocs.GetDescription(),
			HelpName:     corecommon.CreateUsage("setup", setupdocs.GetDescription(), setupdocs.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			UsageText:    setupdocs.GetArguments(),
			BashComplete: corecommon.CreateBashCompletionFunc(setup.GetSupportedPackageManagersList()...),
			Action:       setupCmd,
		},
		{
			Name:         "mvn-config",
			Aliases:      []string{"mvnc"},
			Flags:        cliutils.GetCommandFlags(cliutils.MvnConfig),
			Usage:        mvnconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("mvn-config", mvnconfig.GetDescription(), mvnconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Maven)
			},
		},
		{
			Name:            "mvn",
			Flags:           cliutils.GetCommandFlags(cliutils.Mvn),
			Usage:           mvndoc.GetDescription(),
			HelpName:        corecommon.CreateUsage("mvn", mvndoc.GetDescription(), mvndoc.Usage),
			UsageText:       mvndoc.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(mvndoc.EnvVar...),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action: func(c *cli.Context) (err error) {
				cmdName, _ := getCommandName(c.Args())
				return securityCLI.WrapCmdWithCurationPostFailureRun(c, MvnCmd, techutils.Maven, cmdName)
			},
		},
		{
			Name:         "gradle-config",
			Aliases:      []string{"gradlec"},
			Flags:        cliutils.GetCommandFlags(cliutils.GradleConfig),
			Usage:        gradleconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("gradle-config", gradleconfig.GetDescription(), gradleconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Gradle)
			},
		},
		{
			Name:            "gradle",
			Flags:           cliutils.GetCommandFlags(cliutils.Gradle),
			Usage:           gradledoc.GetDescription(),
			HelpName:        corecommon.CreateUsage("gradle", gradledoc.GetDescription(), gradledoc.Usage),
			UsageText:       gradledoc.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(gradledoc.EnvVar...),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          GradleCmd,
		},
		{
			Name:         "yarn-config",
			Aliases:      []string{"yarnc"},
			Flags:        cliutils.GetCommandFlags(cliutils.YarnConfig),
			Usage:        yarnconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("yarn-config", yarnconfig.GetDescription(), yarnconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Yarn)
			},
		},
		{
			Name:            "yarn",
			Flags:           cliutils.GetCommandFlags(cliutils.Yarn),
			Usage:           yarndocs.GetDescription(),
			HelpName:        corecommon.CreateUsage("yarn", yarndocs.GetDescription(), yarndocs.Usage),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          YarnCmd,
		},
		{
			Name:         "nuget-config",
			Flags:        cliutils.GetCommandFlags(cliutils.NugetConfig),
			Aliases:      []string{"nugetc"},
			Usage:        nugetconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("nuget-config", nugetconfig.GetDescription(), nugetconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Nuget)
			},
		},
		{
			Name:            "nuget",
			Flags:           cliutils.GetCommandFlags(cliutils.Nuget),
			Usage:           nugetdocs.GetDescription(),
			HelpName:        corecommon.CreateUsage("nuget", nugetdocs.GetDescription(), nugetdocs.Usage),
			UsageText:       nugetdocs.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          NugetCmd,
		},
		{
			Name:         "dotnet-config",
			Flags:        cliutils.GetCommandFlags(cliutils.DotnetConfig),
			Aliases:      []string{"dotnetc"},
			Usage:        dotnetconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("dotnet-config", dotnetconfig.GetDescription(), dotnetconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Dotnet)
			},
		},
		{
			Name:            "dotnet",
			Flags:           cliutils.GetCommandFlags(cliutils.Dotnet),
			Usage:           dotnetdocs.GetDescription(),
			HelpName:        corecommon.CreateUsage("dotnet", dotnetdocs.GetDescription(), dotnetdocs.Usage),
			UsageText:       dotnetdocs.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          DotnetCmd,
		},
		{
			Name:         "go-config",
			Aliases:      []string{"goc"},
			Flags:        cliutils.GetCommandFlags(cliutils.GoConfig),
			Usage:        goconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("go-config", goconfig.GetDescription(), goconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Go)
			},
		},
		{
			Name:            "go",
			Flags:           cliutils.GetCommandFlags(cliutils.Go),
			Usage:           gocommand.GetDescription(),
			HelpName:        corecommon.CreateUsage("go", gocommand.GetDescription(), gocommand.Usage),
			UsageText:       gocommand.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action: func(c *cli.Context) (err error) {
				cmdName, _ := getCommandName(c.Args())
				return securityCLI.WrapCmdWithCurationPostFailureRun(c, GoCmd, techutils.Go, cmdName)
			},
		},
		{
			Name:         "go-publish",
			Flags:        cliutils.GetCommandFlags(cliutils.GoPublish),
			Aliases:      []string{"gp"},
			Usage:        gopublish.GetDescription(),
			HelpName:     corecommon.CreateUsage("go-publish", gopublish.GetDescription(), gopublish.Usage),
			UsageText:    gopublish.GetArguments(),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action:       GoPublishCmd,
		},
		{
			Name:         "pip-config",
			Flags:        cliutils.GetCommandFlags(cliutils.PipConfig),
			Aliases:      []string{"pipc"},
			Usage:        pipconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("pip-config", pipconfig.GetDescription(), pipconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Pip)
			},
		},
		{
			Name:            "pip",
			Flags:           cliutils.GetCommandFlags(cliutils.PipInstall),
			Usage:           pipinstall.GetDescription(),
			HelpName:        corecommon.CreateUsage("pip", pipinstall.GetDescription(), pipinstall.Usage),
			UsageText:       pipinstall.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action: func(c *cli.Context) (err error) {
				cmdName, _ := getCommandName(c.Args())
				return securityCLI.WrapCmdWithCurationPostFailureRun(c, PipCmd, techutils.Pip, cmdName)
			},
		},
		{
			Name:         "pipenv-config",
			Flags:        cliutils.GetCommandFlags(cliutils.PipenvConfig),
			Aliases:      []string{"pipec"},
			Usage:        pipenvconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("pipenv-config", pipenvconfig.GetDescription(), pipenvconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Pipenv)
			},
		},
		{
			Name:            "pipenv",
			Flags:           cliutils.GetCommandFlags(cliutils.PipenvInstall),
			Usage:           pipenvinstall.GetDescription(),
			HelpName:        corecommon.CreateUsage("pipenv", pipenvinstall.GetDescription(), pipenvinstall.Usage),
			UsageText:       pipenvinstall.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          PipenvCmd,
		},
		{
			Name:         "poetry-config",
			Flags:        cliutils.GetCommandFlags(cliutils.PoetryConfig),
			Aliases:      []string{"poc"},
			Usage:        poetryconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("poetry-config", poetryconfig.GetDescription(), poetryconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Poetry)
			},
		},
		{
			Name:            "poetry",
			Flags:           cliutils.GetCommandFlags(cliutils.Poetry),
			Usage:           poetry.GetDescription(),
			HelpName:        corecommon.CreateUsage("poetry", poetry.GetDescription(), poetry.Usage),
			UsageText:       poetry.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          PoetryCmd,
		},
		{
			Name:            "helm",
			Flags:           cliutils.GetCommandFlags(cliutils.Helm),
			Usage:           helmcommand.GetDescription(),
			HelpName:        corecommon.CreateUsage("helm", helmcommand.GetDescription(), helmcommand.Usage),
			UsageText:       helmcommand.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          HelmCmd,
		},
		{
			Name:            "conan",
			Flags:           cliutils.GetCommandFlags(cliutils.Conan),
			Usage:           conan.GetDescription(),
			HelpName:        corecommon.CreateUsage("conan", conan.GetDescription(), conan.Usage),
			UsageText:       conan.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			Hidden:          true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          ConanCmd,
		},
		{
			Name:         "ruby-config",
			Flags:        cliutils.GetCommandFlags(cliutils.RubyConfig),
			Aliases:      []string{"rubyc"},
			Usage:        rubyconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("ruby-config", rubyconfig.GetDescription(), rubyconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Ruby)
			},
		},
		{
			Name:         "npm-config",
			Flags:        cliutils.GetCommandFlags(cliutils.NpmConfig),
			Aliases:      []string{"npmc"},
			Usage:        npmconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("npm-config", npmconfig.GetDescription(), npmconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Npm)
			},
		},
		{
			Name:            "npm",
			Usage:           npmcommand.GetDescription(),
			HelpName:        corecommon.CreateUsage("npm", npmcommand.GetDescription(), npmcommand.Usage),
			UsageText:       npmcommand.GetArguments(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc("install", "i", "isntall", "add", "ci", "publish", "p"),
			Category:        buildToolsCategory,
			Action: func(c *cli.Context) (errFromCmd error) {
				cmdName, _ := getCommandName(c.Args())
				return securityCLI.WrapCmdWithCurationPostFailureRun(c,
					func(c *cli.Context) error {
						return npmGenericCmd(c, cmdName, false)
					},
					techutils.Npm, cmdName)
			},
		},
		{
			Name:         "pnpm-config",
			Flags:        cliutils.GetCommandFlags(cliutils.PnpmConfig),
			Aliases:      []string{"pnpmc"},
			Usage:        pnpmconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("pnpm-config", pnpmconfig.GetDescription(), pnpmconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Pnpm)
			},
		},
		{
			Name:            "docker",
			Flags:           cliutils.GetCommandFlags(cliutils.Docker),
			Usage:           docker.GetDescription(),
			HelpName:        corecommon.CreateUsage("docker", docker.GetDescription(), docker.Usage),
			UsageText:       docker.GetArguments(),
			SkipFlagParsing: skipFlagParsingForDockerCmd(),
			BashComplete:    corecommon.CreateBashCompletionFunc("login", "push", "pull", "scan"),
			Category:        buildToolsCategory,
			Action:          dockerCmd,
		},
		{
			Name:         "terraform-config",
			Flags:        cliutils.GetCommandFlags(cliutils.TerraformConfig),
			Aliases:      []string{"tfc"},
			Usage:        terraformconfig.GetDescription(),
			HelpName:     corecommon.CreateUsage("terraform-config", terraformconfig.GetDescription(), terraformconfig.Usage),
			ArgsUsage:    common.CreateEnvVars(),
			BashComplete: corecommon.CreateBashCompletionFunc(),
			Category:     buildToolsCategory,
			Action: func(c *cli.Context) error {
				return cliutils.CreateConfigCmd(c, project.Terraform)
			},
		},
		{
			Name:            "terraform",
			Flags:           cliutils.GetCommandFlags(cliutils.Terraform),
			Aliases:         []string{"tf"},
			Usage:           terraformdocs.GetDescription(),
			HelpName:        corecommon.CreateUsage("terraform", terraformdocs.GetDescription(), terraformdocs.Usage),
			UsageText:       terraformdocs.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          terraformCmd,
		},
		{
			Name:            "twine",
			Flags:           cliutils.GetCommandFlags(cliutils.Twine),
			Usage:           twinedocs.GetDescription(),
			HelpName:        corecommon.CreateUsage("twine", twinedocs.GetDescription(), twinedocs.Usage),
			UsageText:       twinedocs.GetArguments(),
			ArgsUsage:       common.CreateEnvVars(),
			SkipFlagParsing: true,
			BashComplete:    corecommon.CreateBashCompletionFunc(),
			Category:        buildToolsCategory,
			Action:          twineCmd,
		},
	})
	return decorateWithFlagCapture(cmds)
}

func skipFlagParsingForDockerCmd() bool {
	isDockerScan := false
	hasHelpFlag := false
	for i, arg := range os.Args {
		if arg == "docker" && len(os.Args) > i+1 && os.Args[i+1] == "scan" {
			isDockerScan = true
		}
		if arg == "--help" || arg == "-h" {
			hasHelpFlag = true
		}
	}
	// 'docker scan' isn't a docker client command. We won't skip its flags.
	if isDockerScan {
		return hasHelpFlag
	}
	return true
}

// decorateWithFlagCapture injects a Before hook into every command returned from this package,
// so we can capture user-provided flags consistently in one place for all build commands.
func decorateWithFlagCapture(cmds []cli.Command) []cli.Command {
	for i := range cmds {
		skipFlagParsing := cmds[i].SkipFlagParsing
		origBefore := cmds[i].Before
		cmds[i].Before = func(c *cli.Context) error {
			captureUserFlagsForMetrics(c, skipFlagParsing)
			if origBefore != nil {
				return origBefore(c)
			}
			return nil
		}
	}
	return cmds
}

// captureUserFlagsForMetrics extracts flag names as provided by the end-user for the given command
// and records them for usage metrics. Works even when SkipFlagParsing is true by scanning os.Args.
func captureUserFlagsForMetrics(c *cli.Context, skipFlagParsing bool) {
	flagSet := map[string]struct{}{}

	if !skipFlagParsing {
		for _, fn := range c.FlagNames() {
			flagSet[fn] = struct{}{}
		}
	} else {
		for _, next := range c.Args() {
			if !strings.HasPrefix(next, "-") {
				continue
			}
			if strings.HasPrefix(next, "--") {
				name := strings.TrimPrefix(next, "--")
				if eq := strings.Index(name, "="); eq >= 0 {
					name = name[:eq]
				}
				if name != "" {
					flagSet[name] = struct{}{}
				}
			} else {
				trimmed := strings.TrimLeft(next, "-")
				for _, ch := range trimmed {
					flagSet[string(ch)] = struct{}{}
				}
			}
		}
	}

	if len(flagSet) == 0 {
		return
	}
	flags := make([]string, 0, len(flagSet))
	for f := range flagSet {
		flags = append(flags, f)
	}
	sort.Strings(flags)
	commands.SetContextFlags(flags)
}

func MvnCmd(c *cli.Context) (err error) {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}

	// FlexPack bypasses all config file requirements
	if os.Getenv("JFROG_RUN_NATIVE") == "true" {
		log.Debug("Routing to Maven native implementation")
		// Extract build configuration for FlexPack
		args := cliutils.ExtractCommand(c)
		filteredMavenArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(args)
		if err != nil {
			return err
		}
		// Create Maven command with empty config for FlexPack
		mvnCmd := mvn.NewMvnCommand().SetConfigPath("").SetGoals(filteredMavenArgs).SetConfiguration(buildConfiguration)
		return commands.Exec(mvnCmd)
	}

	configFilePath, err := getProjectConfigPathOrThrow(project.Maven, "mvn", "mvn-config")
	if err != nil {
		return err
	}

	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}
	args := cliutils.ExtractCommand(c)
	filteredMavenArgs, insecureTls, err := coreutils.ExtractInsecureTlsFromArgs(args)
	if err != nil {
		return err
	}
	filteredMavenArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(filteredMavenArgs)
	if err != nil {
		return err
	}
	filteredMavenArgs, threads, err := extractThreadsFlag(filteredMavenArgs)
	if err != nil {
		return err
	}
	filteredMavenArgs, detailedSummary, err := coreutils.ExtractDetailedSummaryFromArgs(filteredMavenArgs)
	if err != nil {
		return err
	}
	filteredMavenArgs, xrayScan, err := coreutils.ExtractXrayScanFromArgs(filteredMavenArgs)
	if err != nil {
		return err
	}
	if xrayScan {
		commandsUtils.ConditionalUploadScanFunc = scan.ConditionalUploadDefaultScanFunc
	}
	filteredMavenArgs, format, err := coreutils.ExtractXrayOutputFormatFromArgs(filteredMavenArgs)
	if err != nil {
		return err
	}
	printDeploymentView := log.IsStdErrTerminal()
	if !xrayScan && format != "" {
		return cliutils.PrintHelpAndReturnError("The --format option can be sent only with the --scan option", c)
	}
	scanOutputFormat, err := outputFormat.GetOutputFormat(format)
	if err != nil {
		return err
	}
	mvnCmd := mvn.NewMvnCommand().SetConfiguration(buildConfiguration).SetConfigPath(configFilePath).SetGoals(filteredMavenArgs).SetThreads(threads).SetInsecureTls(insecureTls).SetDetailedSummary(detailedSummary || printDeploymentView).SetXrayScan(xrayScan).SetScanOutputFormat(scanOutputFormat)
	err = commands.Exec(mvnCmd)
	result := mvnCmd.Result()
	defer cliutils.CleanupResult(result, &err)
	err = cliutils.PrintCommandSummary(mvnCmd.Result(), detailedSummary, printDeploymentView, false, err)
	return
}

func GradleCmd(c *cli.Context) (err error) {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}

	configFilePath, err := getProjectConfigPathOrThrow(project.Gradle, "gradle", "gradle-config")
	if err != nil {
		return err
	}

	// Found a config file. Continue as native command.
	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}
	args := cliutils.ExtractCommand(c)
	filteredGradleArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(args)
	if err != nil {
		return err
	}
	filteredGradleArgs, threads, err := extractThreadsFlag(filteredGradleArgs)
	if err != nil {
		return err
	}
	filteredGradleArgs, detailedSummary, err := coreutils.ExtractDetailedSummaryFromArgs(filteredGradleArgs)
	if err != nil {
		return err
	}
	filteredGradleArgs, xrayScan, err := coreutils.ExtractXrayScanFromArgs(filteredGradleArgs)
	if err != nil {
		return err
	}
	if xrayScan {
		commandsUtils.ConditionalUploadScanFunc = scan.ConditionalUploadDefaultScanFunc
	}
	filteredGradleArgs, format, err := coreutils.ExtractXrayOutputFormatFromArgs(filteredGradleArgs)
	if err != nil {
		return err
	}
	if !xrayScan && format != "" {
		return cliutils.PrintHelpAndReturnError("The --format option can be sent only with the --scan option", c)
	}
	scanOutputFormat, err := outputFormat.GetOutputFormat(format)
	if err != nil {
		return err
	}
	printDeploymentView := log.IsStdErrTerminal()
	gradleCmd := gradle.NewGradleCommand().SetConfiguration(buildConfiguration).SetTasks(filteredGradleArgs).SetConfigPath(configFilePath).SetThreads(threads).SetDetailedSummary(detailedSummary || printDeploymentView).SetXrayScan(xrayScan).SetScanOutputFormat(scanOutputFormat)
	err = commands.Exec(gradleCmd)
	result := gradleCmd.Result()
	defer cliutils.CleanupResult(result, &err)
	err = cliutils.PrintCommandSummary(gradleCmd.Result(), detailedSummary, printDeploymentView, false, err)
	return
}

func YarnCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}

	configFilePath, err := getProjectConfigPathOrThrow(project.Yarn, "yarn", "yarn-config")
	if err != nil {
		return err
	}

	yarnCmd := yarn.NewYarnCommand().SetConfigFilePath(configFilePath).SetArgs(c.Args())
	return commands.Exec(yarnCmd)
}

func NugetCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}

	configFilePath, err := getProjectConfigPathOrThrow(project.Nuget, "nuget", "nuget-config")
	if err != nil {
		return err
	}

	rtDetails, targetRepo, useNugetV2, err := getNugetAndDotnetConfigFields(configFilePath)
	if err != nil {
		return err
	}
	args := cliutils.ExtractCommand(c)
	filteredNugetArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(args)
	if err != nil {
		return err
	}

	allowInsecureConnection, err := cliutils.ExtractBoolFlagFromArgs(&filteredNugetArgs, "allow-insecure-connections")
	if err != nil {
		return err
	}

	nugetCmd := dotnet.NewNugetCommand()
	nugetCmd.SetServerDetails(rtDetails).
		SetRepoName(targetRepo).
		SetBuildConfiguration(buildConfiguration).
		SetBasicCommand(filteredNugetArgs[0]).
		SetUseNugetV2(useNugetV2).
		SetAllowInsecureConnections(allowInsecureConnection)
	// Since we are using the values of the command's arguments and flags along the buildInfo collection process,
	// we want to separate the actual NuGet basic command (restore/build...) from the arguments and flags
	if len(filteredNugetArgs) > 1 {
		nugetCmd.SetArgAndFlags(filteredNugetArgs[1:])
	}
	return commands.Exec(nugetCmd)
}

func DotnetCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}

	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}

	// Get configuration file path.
	configFilePath, err := getProjectConfigPathOrThrow(project.Dotnet, "dotnet", "dotnet-config")
	if err != nil {
		return err
	}

	rtDetails, targetRepo, useNugetV2, err := getNugetAndDotnetConfigFields(configFilePath)
	if err != nil {
		return err
	}

	args := cliutils.ExtractCommand(c)

	filteredDotnetArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(args)
	if err != nil {
		return err
	}

	allowInsecureConnection, err := cliutils.ExtractBoolFlagFromArgs(&filteredDotnetArgs, "allow-insecure-connections")
	if err != nil {
		return err
	}

	// Run command.
	dotnetCmd := dotnet.NewDotnetCoreCliCommand()
	dotnetCmd.SetServerDetails(rtDetails).SetRepoName(targetRepo).SetBuildConfiguration(buildConfiguration).
		SetBasicCommand(filteredDotnetArgs[0]).SetUseNugetV2(useNugetV2).SetAllowInsecureConnections(allowInsecureConnection)
	// Since we are using the values of the command's arguments and flags along the buildInfo collection process,
	// we want to separate the actual .NET basic command (restore/build...) from the arguments and flags
	if len(filteredDotnetArgs) > 1 {
		dotnetCmd.SetArgAndFlags(filteredDotnetArgs[1:])
	}
	return commands.Exec(dotnetCmd)
}

func getNugetAndDotnetConfigFields(configFilePath string) (rtDetails *coreConfig.ServerDetails, targetRepo string, useNugetV2 bool, err error) {
	vConfig, err := project.ReadConfigFile(configFilePath, project.YAML)
	if err != nil {
		return nil, "", false, fmt.Errorf("error occurred while attempting to read nuget-configuration file: %s", err.Error())
	}
	projectConfig, err := project.GetRepoConfigByPrefix(configFilePath, project.ProjectConfigResolverPrefix, vConfig)
	if err != nil {
		return nil, "", false, err
	}
	rtDetails, err = projectConfig.ServerDetails()
	if err != nil {
		return nil, "", false, err
	}
	targetRepo = projectConfig.TargetRepo()
	useNugetV2 = vConfig.GetBool(project.ProjectConfigResolverPrefix + "." + "nugetV2")
	return
}

func extractThreadsFlag(args []string) (cleanArgs []string, threadsCount int, err error) {
	// Extract threads flag.
	cleanArgs = append([]string(nil), args...)
	threadsFlagIndex, threadsValueIndex, threads, err := coreutils.FindFlag("--threads", cleanArgs)
	if err != nil || threadsFlagIndex < 0 {
		threadsCount = commonCliUtils.Threads
		return
	}
	coreutils.RemoveFlagFromCommand(&cleanArgs, threadsFlagIndex, threadsValueIndex)

	// Convert flag value to int.
	threadsCount, err = strconv.Atoi(threads)
	if err != nil {
		err = errors.New("The '--threads' option should have a numeric value. " + cliutils.GetDocumentationMessage())
	}
	return
}

func GoCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	configFilePath, err := goCmdVerification(c)
	if err != nil {
		return err
	}
	args := cliutils.ExtractCommand(c)
	goCommand := golang.NewGoCommand()
	goCommand.SetConfigFilePath(configFilePath).SetGoArg(args)
	return commands.Exec(goCommand)
}

func GoPublishCmd(c *cli.Context) (err error) {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	configFilePath, err := goCmdVerification(c)
	if err != nil {
		return err
	}
	buildConfiguration, err := cliutils.CreateBuildConfigurationWithModule(c)
	if err != nil {
		return err
	}
	version := c.Args().Get(0)
	printDeploymentView, detailedSummary := log.IsStdErrTerminal(), c.Bool("detailed-summary")
	goPublishCmd := golang.NewGoPublishCommand()
	goPublishCmd.SetConfigFilePath(configFilePath).SetBuildConfiguration(buildConfiguration).SetVersion(version).SetDetailedSummary(detailedSummary || printDeploymentView).SetExcludedPatterns(cliutils.GetStringsArrFlagValue(c, "exclusions"))
	err = commands.Exec(goPublishCmd)
	result := goPublishCmd.Result()
	defer cliutils.CleanupResult(result, &err)
	err = cliutils.PrintCommandSummary(goPublishCmd.Result(), detailedSummary, printDeploymentView, false, err)
	return
}

func goCmdVerification(c *cli.Context) (string, error) {
	if c.NArg() < 1 {
		return "", cliutils.WrongNumberOfArgumentsHandler(c)
	}

	configFilePath, err := getProjectConfigPathOrThrow(project.Go, "go", "go-config")
	if err != nil {
		return "", err
	}

	log.Debug("Go config file was found in:", configFilePath)
	return configFilePath, nil
}

func dockerCmd(c *cli.Context) error {
	args := cliutils.ExtractCommand(c)
	var cmd, image string
	// We may have prior flags before push/pull commands for the docker client.
	for _, arg := range args {
		if !strings.HasPrefix(arg, "-") {
			if cmd == "" {
				cmd = arg
			} else {
				image = arg
				break
			}
		}
	}
	var err error
	switch cmd {
	case "pull":
		err = pullCmd(c, image)
	case "push":
		err = pushCmd(c, image)
	case "login":
		err = loginCmd(c)
	case "scan":
		return dockerScanCmd(c, image)
		// Handle both build and buildx with same handler
	case "build", "buildx":
		err = buildCmd(c)
	default:
		err = dockerNativeCmd(c)
	}
	if err == nil {
		log.Output(coreutils.PrintTitle("Hint: Use 'jf docker scan' to scan a local Docker image for security vulnerabilities with JFrog Xray"))
	}
	return err
}

func pullCmd(c *cli.Context, image string) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "dockerpullhelp"); show || err != nil {
		return err
	}
	_, rtDetails, _, skipLogin, _, filteredDockerArgs, buildConfiguration, err := extractDockerOptionsFromArgs(c.Args())
	if err != nil {
		return err
	}
	PullCommand := container.NewPullCommand(containerutils.DockerClient)
	PullCommand.SetCmdParams(filteredDockerArgs).SetSkipLogin(skipLogin).SetImageTag(image).SetServerDetails(rtDetails).SetBuildConfiguration(buildConfiguration)
	supported, err := PullCommand.IsGetRepoSupported()
	if err != nil {
		return err
	}
	if !supported {
		return cliutils.NotSupportedNativeDockerCommand("docker-pull")
	}
	return commands.Exec(PullCommand)
}

func pushCmd(c *cli.Context, image string) (err error) {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "dockerpushhelp"); show || err != nil {
		return err
	}
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	threads, rtDetails, detailedSummary, skipLogin, validateSha, filteredDockerArgs, buildConfiguration, err := extractDockerOptionsFromArgs(c.Args())
	if err != nil {
		return
	}
	printDeploymentView := log.IsStdErrTerminal()
	pushCommand := container.NewPushCommand(containerutils.DockerClient)
	pushCommand.SetThreads(threads).SetDetailedSummary(detailedSummary || printDeploymentView).SetCmdParams(filteredDockerArgs).SetSkipLogin(skipLogin).SetBuildConfiguration(buildConfiguration).SetServerDetails(rtDetails).SetValidateSha(validateSha).SetImageTag(image)
	supported, err := pushCommand.IsGetRepoSupported()
	if err != nil {
		return err
	}
	if !supported {
		return cliutils.NotSupportedNativeDockerCommand("docker-push")
	}
	err = commands.Exec(pushCommand)
	result := pushCommand.Result()
	defer cliutils.CleanupResult(result, &err)
	err = cliutils.PrintCommandSummary(pushCommand.Result(), detailedSummary, printDeploymentView, false, err)
	return
}

func buildCmd(c *cli.Context) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "dockerbuildhelp"); show || err != nil {
		return err
	}

	// Extract build configuration and arguments
	_, rtDetails, _, _, _, cleanArgs, buildConfiguration, err := extractDockerOptionsFromArgs(c.Args())
	if err != nil {
		return err
	}
	pushOption, dockerFilePath, imageTag, err := extractDockerBuildOptionsFromArgs(cleanArgs)
	if err != nil {
		return err
	}

	// Login to the docker registry
	err = loginCmd(c)
	if err != nil {
		return err
	}

	dockerOptions := strategies.DockerBuildOptions{
		DockerFilePath: dockerFilePath,
		PushExpected:   pushOption,
		ImageTag:       imageTag,
	}

	buildCommand := container.NewBuildCommand(cleanArgs).SetDockerBuildOptions(dockerOptions).SetBuildConfiguration(buildConfiguration)
	buildCommand.SetServerDetails(rtDetails)

	return commands.Exec(buildCommand)
}

func loginCmd(c *cli.Context) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "dockerloginhelp"); show || err != nil {
		return err
	}

	// extract all options
	_, rtDetails, _, _, _, _, _, err := extractDockerOptionsFromArgs(c.Args())
	if err != nil {
		return err
	}

	// extract login specific options
	user, password, err := extractDockerLoginOptionsFromArgs(c.Args())
	if err != nil {
		return err
	}

	// check if registry is provided by user then use that
	// else use the default from the server details
	// below code checks if the arg after login is not a flag and considers that as the image registry
	var registry string
	for i, arg := range c.Args() {
		if arg == "login" {
			if len(c.Args()) > i+1 && !strings.HasPrefix(c.Args()[i+1], "-") {
				registry = c.Args()[i+1]
				break
			}
			break
		}
	}

	// check if username and password are provided by user then use those to login
	if user != "" && password != "" {
		// registry is mandatory when using username and password
		if registry == "" {
			return errors.New("you need to specify a registry for login using username and password")
		}
		cmd := exec.Command("docker", "login", registry, "-u", user, "-p", password)
		output, err := cmd.CombinedOutput()
		if err != nil {
			return errorutils.CheckErrorf("%s, %s", output, err)
		}
		log.Info(string(output))
		return nil
	}

	// if registry is not provided use the default from the server details
	if registry == "" {
		registry = rtDetails.GetUrl()
	}

	loginCommand := container.NewContainerManagerCommand(containerutils.DockerClient)
	loginCommand.SetPrintConsoleError(true)
	loginCommand.SetServerDetails(rtDetails).SetLoginRegistry(registry)
	// Perform login
	if err := loginCommand.PerformLogin(rtDetails, containerutils.DockerClient); err != nil {
		return err
	}
	// here docker itself returns the login success message, so no need to print it again
	return nil
}

func dockerScanCmd(c *cli.Context, imageTag string) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), securityCLI.DockerScanCmdHiddenName); show || err != nil {
		return err
	}
	convertedCtx, err := components.ConvertContext(c, securityDocs.GetCommandFlags(securityDocs.DockerScan)...)
	if err != nil {
		return err
	}
	return securityCLI.DockerScan(convertedCtx, imageTag)
}

func dockerNativeCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	_, _, _, _, _, cleanArgs, _, err := extractDockerOptionsFromArgs(c.Args())
	if err != nil {
		return err
	}
	cm := containerutils.NewManager(containerutils.DockerClient)
	return cm.RunNativeCmd(cleanArgs)
}

// Remove all the none docker CLI flags from args.
func extractDockerOptionsFromArgs(args []string) (threads int, serverDetails *coreConfig.ServerDetails, detailedSummary, skipLogin bool, validateSha bool, cleanArgs []string, buildConfig *build.BuildConfiguration, err error) {
	cleanArgs = append([]string(nil), args...)
	var serverId string
	cleanArgs, serverId, err = coreutils.ExtractServerIdFromCommand(cleanArgs)
	if err != nil {
		return
	}
	serverDetails, err = coreConfig.GetSpecificConfig(serverId, true, true)
	if err != nil {
		return
	}
	cleanArgs, threads, err = coreutils.ExtractThreadsFromArgs(cleanArgs, 3)
	if err != nil {
		return
	}
	cleanArgs, detailedSummary, err = coreutils.ExtractDetailedSummaryFromArgs(cleanArgs)
	if err != nil {
		return
	}
	cleanArgs, skipLogin, err = coreutils.ExtractSkipLoginFromArgs(cleanArgs)
	if err != nil {
		return
	}
	// Extract validateSha flag
	cleanArgs, validateSha, err = coreutils.ExtractBoolFlagFromArgs(cleanArgs, "validate-sha")
	if err != nil {
		return
	}
	cleanArgs, buildConfig, err = build.ExtractBuildDetailsFromArgs(cleanArgs)
	return
}

func extractDockerLoginOptionsFromArgs(args []string) (user, password string, err error) {
	_, _, user, err = coreutils.FindFlag("-u", args)
	if err != nil {
		return
	}
	if user == "" {
		_, user, err = coreutils.ExtractStringOptionFromArgs(args, "username")
		if err != nil {
			return
		}
	}

	_, _, password, err = coreutils.FindFlag("-p", args)
	if err != nil {
		return
	}
	if password == "" {
		_, password, err = coreutils.ExtractStringOptionFromArgs(args, "password")
		if err != nil {
			return
		}
	}
	return
}

func extractDockerBuildOptionsFromArgs(args []string) (pushOption bool, dockerfilePath string, imageTag string, err error) {
	// check for --push flag or output=type=registry or output=push=true flag, first is the shorthand operator of the later
	_, pushOption, err = coreutils.FindBooleanFlag("--push", args)
	if err != nil {
		return
	}
	_, _, outputOption, err := coreutils.FindFlag("--output", args)
	if err != nil {
		return
	}
	if !pushOption && outputOption != "" &&
		(strings.Contains(outputOption, "type=registry") ||
			(strings.Contains(outputOption, "push=true") && strings.Contains(outputOption, "type=image"))) {
		pushOption = true
	}

	// Check for -f or --file flag
	_, _, dockerfilePath, err = coreutils.FindFlag("-f", args)
	if err != nil || dockerfilePath == "" {
		_, _, dockerfilePath, _ = coreutils.FindFlag("--file", args)
	}
	if dockerfilePath == "" {
		// Default to Dockerfile in current directory
		dockerfilePath = "Dockerfile"
	}

	// Extract image tag from command
	_, _, imageTag, err = coreutils.FindFlag("-t", args)
	if err != nil || imageTag == "" {
		// Try --tag flag as alternative
		_, _, imageTag, _ = coreutils.FindFlag("--tag", args)
	}
	if imageTag == "" {
		err = errors.New("could not find image tag in the command arguments. Please provide an image tag using the '-t' or '--tag' flag")
	}
	return
}

// Assuming command name is the first argument that isn't a flag.
// Returns the command name, and the filtered arguments slice without it.
func getCommandName(orgArgs []string) (string, []string) {
	cmdArgs := make([]string, len(orgArgs))
	copy(cmdArgs, orgArgs)
	for i, arg := range cmdArgs {
		if !strings.HasPrefix(arg, "-") {
			return arg, append(cmdArgs[:i], cmdArgs[i+1:]...)
		}
	}
	return "", cmdArgs
}

// getPrimarySourceFromToml reads pyproject.toml and returns the name of the primary source
// Returns (sourceName, isPrimary) where isPrimary indicates if source has priority='primary'
func getPrimarySourceFromToml() (string, bool) {
	type PyProjectSource struct {
		Name     string `toml:"name"`
		URL      string `toml:"url"`
		Priority string `toml:"priority"`
	}

	type PyProject struct {
		Tool struct {
			Poetry struct {
				Source []PyProjectSource `toml:"source"`
			} `toml:"poetry"`
		} `toml:"tool"`
	}

	tomlPath := filepath.Join(".", "pyproject.toml")
	tomlData, err := os.ReadFile(tomlPath)
	if err != nil {
		return "", false
	}

	var pyproject PyProject
	if err := toml.Unmarshal(tomlData, &pyproject); err != nil {
		return "", false
	}

	// Look for primary source
	for _, source := range pyproject.Tool.Poetry.Source {
		if source.Priority == "primary" {
			return source.Name, true
		}
	}

	// If no primary, use first source
	if len(pyproject.Tool.Poetry.Source) > 0 {
		return pyproject.Tool.Poetry.Source[0].Name, false
	}

	return "", false
}

func NpmInstallCmd(c *cli.Context) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "npminstallhelp"); show || err != nil {
		return err
	}
	return npmGenericCmd(c, "install", true)
}

func NpmCiCmd(c *cli.Context) error {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "npmcihelp"); show || err != nil {
		return err
	}
	return npmGenericCmd(c, "ci", true)
}

func npmGenericCmd(c *cli.Context, cmdName string, collectBuildInfoIfRequested bool) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	switch cmdName {
	// Aliases accepted by npm.
	case "i", "isntall", "add", "install":
		cmdName = "install"
		collectBuildInfoIfRequested = true
	case "ci":
		collectBuildInfoIfRequested = true
	case "publish", "p":
		return NpmPublishCmd(c)
	}

	// Run generic npm command.
	npmCmd := npm.NewNpmCommand(cmdName, collectBuildInfoIfRequested)

	configFilePath, args, err := GetNpmConfigAndArgs(c)
	if err != nil {
		return err
	}
	npmCmd.SetConfigFilePath(configFilePath).SetNpmArgs(args)
	if err = npmCmd.Init(); err != nil {
		return err
	}
	return commands.Exec(npmCmd)
}

func NpmPublishCmd(c *cli.Context) (err error) {
	if show, err := cliutils.ShowGenericCmdHelpIfNeeded(c, c.Args(), "npmpublishhelp"); show || err != nil {
		return err
	}

	configFilePath, args, err := GetNpmConfigAndArgs(c)
	if err != nil {
		return err
	}

	npmCmd := npm.NewNpmPublishCommand()
	npmCmd.SetConfigFilePath(configFilePath).SetArgs(args)
	if err = npmCmd.Init(); err != nil {
		return err
	}
	if npmCmd.GetXrayScan() {
		commandsUtils.ConditionalUploadScanFunc = scan.ConditionalUploadDefaultScanFunc
	}
	// deployment view are not available for native npm commands
	printDeploymentView, detailedSummary := log.IsStdErrTerminal() && !npmCmd.UseNative(), npmCmd.IsDetailedSummary()
	if !detailedSummary {
		npmCmd.SetDetailedSummary(printDeploymentView)
	}
	err = commands.Exec(npmCmd)
	result := npmCmd.Result()
	defer cliutils.CleanupResult(result, &err)
	err = cliutils.PrintCommandSummary(npmCmd.Result(), detailedSummary, printDeploymentView, false, err)
	return
}

func setupCmd(c *cli.Context) (err error) {
	if c.NArg() > 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}
	var packageManager project.ProjectType
	packageManagerStr := c.Args().Get(0)
	// If the package manager was provided as an argument, validate it.
	if packageManagerStr != "" {
		packageManager = project.FromString(packageManagerStr)
		if !setup.IsSupportedPackageManager(packageManager) {
			return cliutils.PrintHelpAndReturnError(fmt.Sprintf("The package manager %s is not supported", packageManagerStr), c)
		}
	} else {
		// If the package manager wasn't provided as an argument, select it interactively.
		packageManager, err = selectPackageManagerInteractively()
		if err != nil {
			return
		}
	}
	setupCmd := setup.NewSetupCommand(packageManager)
	artDetails, err := cliutils.CreateArtifactoryDetailsByFlags(c)
	if err != nil {
		return err
	}
	repoName := c.String("repo")
	if repoName != "" {
		// If a repository was provided, validate it exists in Artifactory.
		if err = validateRepoExists(repoName, artDetails); err != nil {
			return err
		}
	}
	setupCmd.SetServerDetails(artDetails).SetRepoName(repoName).SetProjectKey(cliutils.GetProject(c))
	return commands.Exec(setupCmd)
}

// validateRepoExists checks if the specified repository exists in Artifactory.
func validateRepoExists(repoName string, artDetails *coreConfig.ServerDetails) error {
	serviceDetails, err := artDetails.CreateArtAuthConfig()
	if err != nil {
		return err
	}
	return utils.ValidateRepoExists(repoName, serviceDetails)
}

func selectPackageManagerInteractively() (selectedPackageManager project.ProjectType, err error) {
	var selected string
	var selectableItems []ioutils.PromptItem
	for _, packageManager := range setup.GetSupportedPackageManagersList() {
		selectableItems = append(selectableItems, ioutils.PromptItem{Option: packageManager, TargetValue: &selected})
	}
	err = ioutils.SelectString(selectableItems, "Please select a package manager to set up:", false, func(item ioutils.PromptItem) {
		*item.TargetValue = item.Option
		selectedPackageManager = project.FromString(*item.TargetValue)
	})
	return
}

func GetNpmConfigAndArgs(c *cli.Context) (configFilePath string, args []string, err error) {
	configFilePath, err = getProjectConfigPathOrThrow(project.Npm, "npm", "npm-config")
	if err != nil {
		return
	}
	_, args = getCommandName(c.Args())
	return
}

func PipCmd(c *cli.Context) error {
	return pythonCmd(c, project.Pip)
}

func PipenvCmd(c *cli.Context) error {
	return pythonCmd(c, project.Pipenv)
}

func PoetryCmd(c *cli.Context) error {
	return pythonCmd(c, project.Poetry)
}

// HelmCmd executes Helm commands with build info collection support
func HelmCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}

	args := cliutils.ExtractCommand(c)
	cmdName, helmArgs := getCommandName(args)

	filteredArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(helmArgs)
	if err != nil {
		return err
	}

	repositoryCachePath := extractRepositoryCacheFromArgs(helmArgs)
	serverDetails, err := extractHelmServerDetails(filteredArgs)
	if err != nil {
		return err
	}

	restoreEnv, err := setHelmRepositoryCache(repositoryCachePath)
	if err != nil {
		return err
	}
	defer restoreEnv()

	workingDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	helmCmd := helmcmd.NewHelmCommand().
		SetHelmArgs(filteredArgs).
		SetBuildConfiguration(buildConfiguration).
		SetServerDetails(serverDetails).
		SetWorkingDirectory(workingDir).
		SetHelmCmdName(cmdName)

	return commands.Exec(helmCmd)
}

// extractRepositoryCacheFromArgs extracts the --repository-cache flag value from Helm command arguments.
// It supports both --repository-cache=path and --repository-cache path formats.
func extractRepositoryCacheFromArgs(args []string) string {
	const flagName = "--repository-cache"
	const flagPrefix = flagName + "="

	for i, arg := range args {
		if strings.HasPrefix(arg, flagPrefix) {
			return strings.TrimPrefix(arg, flagPrefix)
		}
		if arg == flagName && i+1 < len(args) {
			return args[i+1]
		}
	}
	return ""
}

// extractHelmServerDetails extracts server ID from arguments and retrieves server details.
// Returns nil serverDetails if no server ID is provided.
func extractHelmServerDetails(args []string) (*coreConfig.ServerDetails, error) {
	_, serverID, err := coreutils.ExtractServerIdFromCommand(args)
	if err != nil {
		return nil, fmt.Errorf("failed to extract server ID: %w", err)
	}

	if serverID == "" {
		return nil, nil
	}

	serverDetails, err := coreConfig.GetSpecificConfig(serverID, true, true)
	if err != nil {
		return nil, fmt.Errorf("failed to get server configuration for ID '%s': %w", serverID, err)
	}

	return serverDetails, nil
}

// setHelmRepositoryCache sets or unsets HELM_REPOSITORY_CACHE environment variable.
// Returns a restore function that should be called in a defer to restore the original value.
func setHelmRepositoryCache(cachePath string) (func(), error) {
	const envVarName = "HELM_REPOSITORY_CACHE"
	originalValue := os.Getenv(envVarName)

	if cachePath != "" {
		if err := os.Setenv(envVarName, cachePath); err != nil {
			return nil, fmt.Errorf("failed to set %s environment variable: %w", envVarName, err)
		}
	} else {
		if err := os.Unsetenv(envVarName); err != nil {
			return nil, fmt.Errorf("failed to unset %s environment variable: %w", envVarName, err)
		}
	}
	restoreFunc := func() {
		if originalValue != "" {
			_ = os.Setenv(envVarName, originalValue)
		} else {
			_ = os.Unsetenv(envVarName)
		}
	}

	return restoreFunc, nil
}

func ConanCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}

	args := cliutils.ExtractCommand(c)
	cmdName, conanArgs := getCommandName(args)

	// Execute native conan command directly
	log.Info(fmt.Sprintf("Running Conan %s.", cmdName))
	conanCmd := exec.Command("conan", append([]string{cmdName}, conanArgs...)...)
	conanCmd.Stdout = os.Stdout
	conanCmd.Stderr = os.Stderr
	if err := conanCmd.Run(); err != nil {
		return fmt.Errorf("conan %s failed: %w", cmdName, err)
	}

	return nil
}

func pythonCmd(c *cli.Context, projectType project.ProjectType) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	if c.NArg() < 1 {
		return cliutils.WrongNumberOfArgumentsHandler(c)
	}

	// FlexPack native mode for Poetry (bypasses config file requirements)
	if os.Getenv("JFROG_RUN_NATIVE") == "true" && projectType == project.Poetry {
		log.Debug("Routing to Poetry native implementation")
		args := cliutils.ExtractCommand(c)
		filteredArgs, buildConfiguration, err := build.ExtractBuildDetailsFromArgs(args)
		if err != nil {
			return err
		}
		cmdName, poetryArgs := getCommandName(filteredArgs)

		// Extract --repository flag for artifact collection (if publishing)
		deployerRepo := ""
		for i, arg := range poetryArgs {
			if strings.HasPrefix(arg, "--repository=") {
				deployerRepo = strings.TrimPrefix(arg, "--repository=")
			} else if (arg == "--repository" || arg == "-r") && i+1 < len(poetryArgs) {
				deployerRepo = poetryArgs[i+1]
			}
		}

		// Auto-add repository flag if not provided and we're publishing
		if cmdName == "publish" && deployerRepo == "" {
			// Try to get primary source from pyproject.toml (same as native Poetry behavior)
			if repoName, isPrimary := getPrimarySourceFromToml(); repoName != "" {
				if isPrimary {
					log.Info(fmt.Sprintf("No --repository flag specified. Using '%s' from pyproject.toml (priority='primary')", repoName))
				} else {
					log.Info(fmt.Sprintf("No --repository flag specified. Using '%s' from pyproject.toml (first source)", repoName))
				}
				poetryArgs = append([]string{"-r", repoName}, poetryArgs...)
				deployerRepo = repoName
			} else {
				log.Warn("No repository specified and no sources found in pyproject.toml. Poetry will attempt to publish to PyPI.")
			}
		} else if cmdName == "publish" && deployerRepo != "" {
			log.Info(fmt.Sprintf("Publishing to repository: %s (from --repository flag)", deployerRepo))
		}

		// Execute native poetry command directly (similar to Maven FlexPack)
		log.Info(fmt.Sprintf("Running Poetry %s.", cmdName))
		poetryCmd := exec.Command("poetry", append([]string{cmdName}, poetryArgs...)...)
		poetryCmd.Stdout = os.Stdout
		poetryCmd.Stderr = os.Stderr
		if err := poetryCmd.Run(); err != nil {
			return fmt.Errorf("poetry %s failed: %w", cmdName, err)
		}

		// Collect build info if build parameters provided
		if buildConfiguration != nil {
			buildName, err := buildConfiguration.GetBuildName()
			if err == nil && buildName != "" {
				workingDir, err := os.Getwd()
				if err != nil {
					log.Warn("Failed to get working directory, skipping build info collection: " + err.Error())
				} else if err := buildinfo.GetPoetryBuildInfo(workingDir, buildConfiguration, deployerRepo); err != nil {
					log.Warn("Failed to collect Poetry build info: " + err.Error())
				} else {
					buildNumber, err := buildConfiguration.GetBuildNumber()
					if err != nil {
						log.Warn("Failed to get build number: " + err.Error())
					} else {
						log.Info(fmt.Sprintf("Poetry build info collected. Use 'jf rt bp %s %s' to publish it to Artifactory.", buildName, buildNumber))
					}
				}
			}
		}

		return nil
	}

	// Get python configuration.
	pythonConfig, err := project.GetResolutionOnlyConfiguration(projectType)
	if err != nil {
		return fmt.Errorf("error occurred while attempting to read %[1]s-configuration file: %[2]s\n"+
			"Please run 'jf %[1]s-config' command prior to running 'jf %[1]s'", projectType.String(), err.Error())
	}

	// Set arg values.
	rtDetails, err := pythonConfig.ServerDetails()
	if err != nil {
		return err
	}

	orgArgs := cliutils.ExtractCommand(c)
	cmdName, filteredArgs := getCommandName(orgArgs)
	switch projectType {
	case project.Pip:
		pipCommand := python.NewPipCommand()
		pipCommand.SetServerDetails(rtDetails).SetRepo(pythonConfig.TargetRepo()).SetCommandName(cmdName).SetArgs(filteredArgs)
		return commands.Exec(pipCommand)
	case project.Pipenv:
		pipenvCommand := python.NewPipenvCommand()
		pipenvCommand.SetServerDetails(rtDetails).SetRepo(pythonConfig.TargetRepo()).SetCommandName(cmdName).SetArgs(filteredArgs)
		return commands.Exec(pipenvCommand)
	case project.Poetry:
		poetryCommand := python.NewPoetryCommand()
		poetryCommand.SetServerDetails(rtDetails).SetRepo(pythonConfig.TargetRepo()).SetCommandName(cmdName).SetArgs(filteredArgs)
		return commands.Exec(poetryCommand)
	default:
		return errorutils.CheckErrorf("%s is not supported", projectType)
	}
}

func terraformCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	configFilePath, orgArgs, err := getTerraformConfigAndArgs(c)
	if err != nil {
		return err
	}
	cmdName, filteredArgs := getCommandName(orgArgs)
	switch cmdName {
	// Aliases accepted by terraform.
	case "publish", "p":
		return terraformPublishCmd(configFilePath, filteredArgs, c)
	default:
		return errorutils.CheckErrorf("Terraform command: '%s' is not supported. %s", cmdName, cliutils.GetDocumentationMessage())
	}
}

func getTerraformConfigAndArgs(c *cli.Context) (configFilePath string, args []string, err error) {
	configFilePath, err = getProjectConfigPathOrThrow(project.Terraform, "terraform", "terraform-config")
	if err != nil {
		return
	}
	args = cliutils.ExtractCommand(c)
	return
}

func terraformPublishCmd(configFilePath string, args []string, c *cli.Context) error {
	terraformCmd := terraform.NewTerraformPublishCommand()
	terraformCmd.SetConfigFilePath(configFilePath).SetArgs(args)
	if err := terraformCmd.Init(); err != nil {
		return err
	}
	err := commands.Exec(terraformCmd)
	result := terraformCmd.Result()
	return cliutils.PrintBriefSummaryReport(result.SuccessCount(), result.FailCount(), cliutils.IsFailNoOp(c), err)
}

func getProjectConfigPathOrThrow(projectType project.ProjectType, cmdName, configCmdName string) (configFilePath string, err error) {
	configFilePath, exists, err := project.GetProjectConfFilePath(projectType)
	if err != nil {
		return
	}
	if !exists {
		return "", errorutils.CheckErrorf("%s", getMissingConfigErrMsg(cmdName, configCmdName))
	}
	return
}

func getMissingConfigErrMsg(cmdName, configCmdName string) string {
	return fmt.Sprintf("no config file was found! Before running the 'jf %s' command on a project for the first time, the project should be configured with the 'jf %s' command", cmdName, configCmdName)
}

func twineCmd(c *cli.Context) error {
	if show, err := cliutils.ShowCmdHelpIfNeeded(c, c.Args()); show || err != nil {
		return err
	}
	serverDetails, targetRepo, err := getTwineConfigAndArgs()
	if err != nil {
		return err
	}
	cmdName, filteredArgs := getCommandName(cliutils.ExtractCommand(c))
	return python.NewTwineCommand(cmdName).SetServerDetails(serverDetails).SetTargetRepo(targetRepo).SetArgs(filteredArgs).Run()
}

func getTwineConfigAndArgs() (serverDetails *coreConfig.ServerDetails, targetRepo string, err error) {
	configFilePath, err := getTwineConfigPath()
	if err != nil {
		return
	}

	vConfig, err := project.ReadConfigFile(configFilePath, project.YAML)
	if err != nil {
		return nil, "", fmt.Errorf("failed while reading configuration file '%s'. Error: %s", configFilePath, err.Error())
	}
	projectConfig, err := project.GetRepoConfigByPrefix(configFilePath, project.ProjectConfigDeployerPrefix, vConfig)
	if err != nil {
		return nil, "", err
	}
	serverDetails, err = projectConfig.ServerDetails()
	if err != nil {
		return nil, "", err
	}
	targetRepo = projectConfig.TargetRepo()
	return
}

func getTwineConfigPath() (configFilePath string, err error) {
	var exists bool
	for _, projectType := range []project.ProjectType{project.Pip, project.Pipenv} {
		configFilePath, exists, err = project.GetProjectConfFilePath(projectType)
		if err != nil || exists {
			return
		}
	}
	return "", errorutils.CheckErrorf("%s", getMissingConfigErrMsg("twine", "pip-config OR pipenv-config"))
}
